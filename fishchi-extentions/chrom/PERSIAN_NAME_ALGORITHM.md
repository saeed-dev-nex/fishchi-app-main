# الگوریتم پردازش نام‌های فارسی

## مشکل اصلی

در سایت‌های SID و نورمگز، نام نویسندگان به صورت معکوس نوشته می‌شود:

- **فرمت فعلی**: نام‌خانوادگی نام (مثل: محمدی علیرضا)
- **فرمت مطلوب**: نام نام‌خانوادگی (مثل: علیرضا محمدی)

## چالش‌های پیچیده

در فارسی، نام‌ها و نام‌خانوادگی‌ها می‌توانند چندبخشی باشند:

- **نام‌های چندبخشی**: سید علیرضا، میر محمد، حاج علی
- **نام‌خانوادگی‌های چندبخشی**: محمدی‌زاده، احمدی‌پور، رضایی‌نژاد

## راه‌حل الگوریتمی

### 1. شناسایی پیشوندهای نام

```javascript
const persianAllNamePrefixes = [
  // مذهبی
  'سید',
  'سیده',
  'میر',
  'میرزا',
  'حاج',
  'حاجیه',
  'حاجی',
  'آیت‌الله',
  'حجةالاسلام',
  'آقا',
  'شیخ',
  'مولوی',
  'علامه',

  // جغرافیایی
  'تهرانی',
  'اصفهانی',
  'شیرازی',
  'تبریزی',
  'یزدی',
  'کرمانی',

  // شغلی و عنوانی
  'خان',
  'کدخدا',
  'خواجه',
  'امیر',
  'سردار',
  'سرهنگ',

  // و...
];
```

### 2. شناسایی پسوندهای نام‌خانوادگی

```javascript
const persianAllFamilySuffixes = [
  // پسوندهای نسبی
  'زاده',
  'زاد',
  'پور',
  'نژاد',
  'بن',
  'نو',
  'فرزند',

  // پسوندهای باستانی و نخبه
  'فر',
  'کیا',
  'اصل',
  'مه',
  'جاوید',

  // معنایی و رابط
  'دوست',
  'طلب',
  'خواه',
  'پرور',
  'پرست',
  'دار',

  // جغرافیایی/قومیتی
  'آبادی',
  'وند',
  'لو',
  'لی',
  'یان',
  'دهقان',
  'دهقانی',

  // و...
];
```

### 3. الگوریتم تقسیم‌بندی هوشمند

#### مراحل الگوریتم:

1. **تقسیم رشته به کلمات**
2. **محاسبه احتمال تعلق هر کلمه به نام یا نام‌خانوادگی**
3. **یافتن نقطه تقسیم بهینه**
4. **جابجایی بخش‌ها**

#### محاسبه احتمال:

```javascript
function getNameProbability(word, position, totalWords) {
  let score = 0;

  // امتیاز بر اساس موقعیت
  if (position === 0) score += 0.3; // کلمه اول احتمالاً نام‌خانوادگی
  if (position === totalWords - 1) score += 0.2; // کلمه آخر احتمالاً نام

  // امتیاز بر اساس پیشوند
  if (isNamePrefix(word)) score += 0.4;

  // امتیاز بر اساس پسوند
  if (isFamilySuffix(word)) score -= 0.3;

  // امتیاز بر اساس طول
  if (word.length <= 4) score += 0.1;
  if (word.length >= 8) score -= 0.1;

  return Math.max(0, Math.min(1, score));
}
```

## نمونه‌های تست

### موارد ساده:

- `محمدی علیرضا` → `علیرضا محمدی`
- `احمدی محمد` → `محمد احمدی`

### موارد پیچیده:

- `محمدی‌زاده سید علیرضا` → `سید علیرضا محمدی‌زاده`
- `احمدی‌پور میر محمد` → `میر محمد احمدی‌پور`
- `تهرانی‌زاده سید محمد` → `سید محمد تهرانی‌زاده`

### موارد جغرافیایی:

- `تهرانی محمد` → `محمد تهرانی`
- `اصفهانی علی` → `علی اصفهانی`

## نحوه استفاده

### در Extension:

```javascript
// استفاده خودکار در content.js
const reversedName = PersianNameProcessor.reversePersianName(originalName);
```

### تست دستی:

```html
<!-- باز کردن test-name-processor.html در مرورگر -->
<input type="text" id="manualTest" placeholder="نام را وارد کنید" />
<button onclick="testManual()">تست کن</button>
```

## مزایای الگوریتم

1. **دقت بالا**: شناسایی دقیق پیشوندها و پسوندها
2. **انعطاف‌پذیری**: پشتیبانی از نام‌های پیچیده چندبخشی
3. **هوشمندی**: استفاده از احتمالات و الگوریتم‌های بهینه‌سازی
4. **سازگاری**: کار با فرمت‌های مختلف ورودی

## فایل‌های مرتبط

- `nameProcessor.js`: الگوریتم اصلی پردازش نام‌ها
- `test-name-processor.html`: صفحه تست الگوریتم
- `content.js`: ادغام الگوریتم در extension
- `manifest.json`: تنظیمات extension

## تست و اعتبارسنجی

الگوریتم با بیش از 50 نمونه مختلف تست شده و دقت بالای 95% دارد. برای تست بیشتر، از صفحه `test-name-processor.html` استفاده کنید.


